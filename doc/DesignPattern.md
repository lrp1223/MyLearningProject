# Design Pattern

## Chapter2 Simple Factory(简单工厂模式)
Simple factory: create interface or abstract class, even class;   
Static factory: Simple factory + static method;   
万能工厂：
#### 优点：帮助封装；解耦；
#### 缺点：增加客户端复杂度；不方便扩展子工厂；
#### 本质：选择实现；

## Chapter3 Facade(外观模式)
目的：让外部减少与子系统的内部多个模块的交互，松散耦合；
### 优点： 松散耦合，简单易用。。。
### 缺点：不合理的Facade容易让人迷惑；
### 本质：封装交互，简化调用；
相关模式：**中介者模式；**

## Chapter4 Adapter(适配器模式)
将一个类的接口转换成客户希望的另外一个接口；
适配器通常是一个类，一般让适配器类去实现Target接口，然后在适配器具体实现里面调用Adaptee；
### 优点：更好的复用，更好的可扩展性；
### 缺点：过多的使用，会让系统非常凌乱，不容易整体进行把握；
### 本质：转换匹配，复用功能；

## Chapter5 Singleton(单例模式)
保证一个类仅有一个实例，并提供一个它的全局的访问点；
懒汉模式：
饿汉模式：
### 本质：控制实例数目；

## Chapter6 Factory Method(工厂方法模式)
模式比框架更抽象；
### 优点：可以在不知道具体实现的情况下编程；更容易扩展对象的新版本；连接平行的类层次；
### 缺点：具体产品对象和工厂方法的耦合性；
### 本质：延迟到子类来选择实现；

## Chapter7 Abstract Factory(抽象工厂模式)
提供一个创建一系列相关或相互依赖的接口，而无需指定它们的具体的类。
抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。AbstractFactory在Java中通常实现成为**接口**。
### 优点：分离接口和实现；使得切换产品簇变得容易；
### 缺点：不太容易扩展新的产品；容易造成类层次复杂；

## Chapter8 Builder(生成器模式)
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
### 优点：松散耦合；可以更容易的改变产品的内部表示；更好的复用性；
### 本质：分离整体的构建算法和部件构建；

## Chapter9 Prototype(原型模式)
用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
浅度克隆：只负责克隆按值传递的数据(String, int等基本数据类型)；
深度克隆：克隆引用类型的数据--需要调用引用类型的克隆方法；
### 本质：克隆生成对象；
### 优点：对客户隐藏具体的实现类型；在运行时改变具体的实现类型；
### 缺点：每个原型的子类都必须实现Clone；

## Chapter10 Mediator(中介者模式)
封装一系列的对象交互。中介者不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
### 优点：松散耦合；集中控制交互；多对多变成一对多；
### 缺点：过度集中化；
### 本质：封装交互；

## Chapter11 Proxy(代理模式)
为其他对象提供一种代理以控制对这个对象的访问；
Java动态代理是实现AOP的一个重要手段；
### 本质：控制对象访问；
需要一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理；
需要按照需要创建开销很大的对象的时候，可以使用虚代理；

## Chapter12 Observer(观察者模式)
定义对象间的一种一对多的依赖关系。
### 优点：观察者和目标之间的抽象耦合；实现了动态联动；支持广播通信；
### 缺点：可能会引起无谓的操作；
### 本质：触发联动；

## Chapter13 Command(命令模式)
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
宏命令；
队列请求；
日志请求=>事务；
### 优点：更松散的耦合--发起命令的对象-客户端和具体实现命令的对象-接受者对象完全解耦；更动态的控制；更好的扩展性；
### 本质：封装请求；

## Chapter14 Iterator(迭代器模式)
提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示。
内部迭代器和外部迭代器(显示调用next来迭代下一个元素)。
双向迭代器；
### 优点：更好的封装；简化了聚合的接口；
### 本质：控制访问聚合对象中的元素；
翻页：数据库--时间换空间；纯内存实现--空间换时间

## Chapter15 Composite(组合模式)
将对象组合成树型结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
**目的**：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。
**关键**：设计一个抽象的组件类。
### 优点：定义包含基本对象和组合对象的类层次结构；统一了组合对象和叶子对象；简化了客户端调用；更容易扩展；
### 缺点：很难限制组合中的组件类型；
### 本质：统一叶子对象和组合对象；

## Chapter16 Template Method(模板方法模式)
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
既要约束子类的行为，又要为子类提供公共功能的时候使用抽象类。
Java中的理论依据“后期绑定”技术。
### 优点：实现代码复用；
### 缺点：算法骨架不容易升级；
### 本质：固定算法框架；
使用继承的方式是类级别的关系；使用Java回调这个关系是在运行期间决定的，是对象级的关系。

## Chapter17 Strategy(策略模式)
定义一系列算法，把他们一个个封装起来，并且使他们可相互替换。
多个if else语句可以考虑使用策略模式；
策略算法是相同行为的不同实现；
### 优点：定义一系列算法；避免多重条件语句；更好的扩展性；
### 缺点：客户必须了解每种策略的不同；增加了对象数目；只适合扁平的算法结构；
### 本质：分离算法，选择实现；

## Chapter18 State（状态模式）
允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
状态模式的功能就是分离状态的行为；**状态决定行为**
### 优点：简化应用逻辑；更好地分离状态和行为；更好的扩展性；显示化进行状态转换；
### 缺点：引入太多的状态类，使得程序变得杂乱；
### 本质：根据状态来分离和选择行为；

## Chapter19 Memento(备忘录模式)
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
备忘录对象是一个私有的内部类，外面只能通过备忘录对象的窄接口来获取备忘录对象。备忘录对象只让原发器对象来操作。
### 优点：更好的封装性；简化了原发器；
### 缺点：可能会导致高开销；
### 本质：保存和恢复内部状态；
保存时手段，恢复才是目的。

## Chapter20 Flyweight(享元模式)
权限系统：授权部分（权限的分配过程）和验证部分（权限的匹配过程）。
运用共享技术有效地支持大量细粒度的对象。
分离变与不变是软件设计上最基本的方式之一。
### 优点：减少对象数量，节省内存空间；
### 缺点：维护共享对象，需要额外开销；
### 本质：分离与共享；

## Chapter21 Interpretor(解释器模式)
给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

## Chapter22 Decorator(装饰模式)


## Chapter23 Chain of Responsibility(职责链模式)


## Chapter24 Bridge(桥接模式)


## Chapter25 Visitor(访问模式)
