# Design Pattern

## Chapter2 Simple Factory(简单工厂模式)
Simple factory: create interface or abstract class, even class;   
Static factory: Simple factory + static method;   
万能工厂：
#### 优点：帮助封装；解耦；
#### 缺点：增加客户端复杂度；不方便扩展子工厂；
#### 本质：选择实现；

## Chapter3 Facade(外观模式)
目的：让外部减少与子系统的内部多个模块的交互，松散耦合；
### 优点： 松散耦合，简单易用。。。
### 缺点：不合理的Facade容易让人迷惑；
### 本质：封装交互，简化调用；
相关模式：**中介者模式；**

## Chapter4 Adapter(适配器模式)
将一个类的接口转换成客户希望的另外一个接口；
适配器通常是一个类，一般让适配器类去实现Target接口，然后在适配器具体实现里面调用Adaptee；
### 优点：更好的复用，更好的可扩展性；
### 缺点：过多的使用，会让系统非常凌乱，不容易整体进行把握；
### 本质：转换匹配，复用功能；

## Chapter5 Singleton(单例模式)
保证一个类仅有一个实例，并提供一个它的全局的访问点；
懒汉模式：
饿汉模式：
### 本质：控制实例数目；

## Chapter6 Factory Method(工厂方法模式)
模式比框架更抽象；
### 优点：可以在不知道具体实现的情况下编程；更容易扩展对象的新版本；连接平行的类层次；
### 缺点：具体产品对象和工厂方法的耦合性；
### 本质：延迟到子类来选择实现；

## Chapter7 Abstract Factory(抽象工厂模式)
提供一个创建一系列相关或相互依赖的接口，而无需指定它们的具体的类。
抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。AbstractFactory在Java中通常实现成为**接口**。
### 优点：分离接口和实现；使得切换产品簇变得容易；
### 缺点：不太容易扩展新的产品；容易造成类层次复杂；

## Chapter8 Builder(生成器模式)
将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
### 优点：松散耦合；可以更容易的改变产品的内部表示；更好的复用性；
### 本质：分离整体的构建算法和部件构建；

## Chapter9 Prototype(原型模式)
用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。
浅度克隆：只负责克隆按值传递的数据(String, int等基本数据类型)；
深度克隆：克隆引用类型的数据--需要调用引用类型的克隆方法；
### 本质：克隆生成对象；
### 优点：对客户隐藏具体的实现类型；在运行时改变具体的实现类型；
### 缺点：每个原型的子类都必须实现Clone；

## Chapter10 Mediator(中介者模式)
封装一系列的对象交互。中介者不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
### 优点：松散耦合；集中控制交互；多对多变成一对多；
### 缺点：过度集中化；
### 本质：封装交互；

## Chapter11 Proxy(代理模式)
为其他对象提供一种代理以控制对这个对象的访问；
Java动态代理是实现AOP的一个重要手段；
### 本质：控制对象访问；
需要一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理；
需要按照需要创建开销很大的对象的时候，可以使用虚代理；

## Chapter12 Observer(观察者模式)
定义对象间的一种一对多的依赖关系。
### 优点：观察者和目标之间的抽象耦合；实现了动态联动；支持广播通信；
### 缺点：可能会引起无谓的操作；
### 本质：触发联动；

## Chapter13 Command(命令模式)
将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
宏命令；
队列请求；
日志请求=>事务；
### 优点：更松散的耦合--发起命令的对象-客户端和具体实现命令的对象-接受者对象完全解耦；更动态的控制；更好的扩展性；
### 本质：封装请求；

## Chapter14 Iterator(迭代器模式)
提供一种方法顺序访问一个聚合对象中的各个元素，而又不需暴露该对象的内部表示。
内部迭代器和外部迭代器(显示调用next来迭代下一个元素)。
双向迭代器；
### 优点：更好的封装；简化了聚合的接口；
### 本质：控制访问聚合对象中的元素；
翻页：数据库--时间换空间；纯内存实现--空间换时间

## Chapter15 Composite(组合模式)
将对象组合成树型结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。
**目的**：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作。
**关键**：设计一个抽象的组件类。
### 优点：定义包含基本对象和组合对象的类层次结构；统一了组合对象和叶子对象；简化了客户端调用；更容易扩展；
### 缺点：很难限制组合中的组件类型；
### 本质：统一叶子对象和组合对象；

## Chapter16 Template Method(模板方法模式)
定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
既要约束子类的行为，又要为子类提供公共功能的时候使用抽象类。
Java中的理论依据“后期绑定”技术。
### 优点：实现代码复用；
### 缺点：算法骨架不容易升级；
### 本质：固定算法框架；
使用继承的方式是类级别的关系；使用Java回调这个关系是在运行期间决定的，是对象级的关系。

## Chapter17 Strategy(策略模式)
